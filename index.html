<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Document</title>
</head>
<body>
    <header>
        <div class="container header-flex">
            <div>
                <p class="header-text">Блог для react разработчиков</p>
                <h1 class="header-title">React Blog</h1>
                <h2 class="header-text">В данном блоге вы найдете все что нужно react разработчику и не только. У нас так же есть курсы для начинающих</h2>
                <button class="header-btn">Попробывать</button>
            </div>
            <img class="header-img" src="1.png" alt="">
        </div>
    </header>
    <main>
        <section class="container">
            <article>
                Философия React<br />
React&nbsp;&mdash; это отличный способ писать большие и&nbsp;быстрые JavaScript-приложения. Мы&nbsp;в&nbsp;Facebook и&nbsp;Instagram убедились в&nbsp;его хорошей масштабируемости.<br />
<ul>
    <li>
        Легок в изучении. React гораздо легче учится ввиду простоты его синтаксиса. Инженеры просто должны вспомнить свои навыки написания HTML и всё на этом. Нет нужды в глубоком изучении TypeScript, как в случае с Angular. 
    </li>
    <li>
        Высокий уровень гибкости и максимальная отзывчивость.
    </li>
    <li>
        Виртуальная DOM (document object model), которая позволяет упорядочивать документы форматов HTML, XHTML или XML в дерево, которое лучше всего подходит веб-браузерам для анализа различных элементов веб-приложения.
    </li>
    <li>
        В сочетании с ES6/7 ReactJS может легко работать при высоких нагрузках.
    </li>
    <li>
        Связывание данных от больших к меньшим. Это означает такой поток данных, при котором дочерние элементы не могут влиять на родительские данные.
    </li>
</ul>
Одна из&nbsp;особенностей React&nbsp;&mdash; это предлагаемый им&nbsp;процесс мышления при создании приложений. В&nbsp;этом руководстве мы&nbsp;разберём пример создания таблицы продуктов с&nbsp;поиском на&nbsp;React.<br />
<br />
Начнём с&nbsp;макета<br />
Представьте, что у&nbsp;вас уже есть JSON API и&nbsp;макет дизайна сайта. 
Наш JSON API возвращает данные, которые выглядят так:<br />
<br />
<code>
    [<br />
    {category: &laquo;Sporting Goods&raquo;, price: &laquo;$49.99&raquo;, stocked: true, name: &laquo;Football&raquo;},<br />
    {category: &laquo;Sporting Goods&raquo;, price: &laquo;$9.99&raquo;, stocked: true, name: &laquo;Baseball&raquo;},<br />
    {category: &laquo;Sporting Goods&raquo;, price: &laquo;$29.99&raquo;, stocked: false, name: &laquo;Basketball&raquo;},<br />
    {category: &laquo;Electronics&raquo;, price: &laquo;$99.99&raquo;, stocked: true, name: &laquo;iPod Touch&raquo;},<br />
    {category: &laquo;Electronics&raquo;, price: &laquo;$399.99&raquo;, stocked: false, name: &laquo;iPhone 5&raquo;},<br />
    {category: &laquo;Electronics&raquo;, price: &laquo;$199.99&raquo;, stocked: true, name: &laquo;Nexus&nbsp;7&raquo;}<br />
    ];<br />
</code>

Шаг&nbsp;1: Разобьём интерфейс на&nbsp;составляющие<br />
Первое, что нужно сделать&nbsp;&mdash; выделить отдельные компоненты (и&nbsp;подкомпоненты) в&nbsp;макете и&nbsp;дать им&nbsp;имена. Если вы&nbsp;работаете с&nbsp;дизайнерами, вполне возможно, что они уже как-то называют компоненты&nbsp;&mdash; вам стоит пообщаться! Например, слои Photoshop часто подсказывают имена для React-компонентов.<br />
<br />
Но&nbsp;как узнать, что стоит делать отдельным компонентом, а&nbsp;что нет? Используйте тот&nbsp;же подход, как при решении создать простую функцию или целый объект. Можно применить принцип единственной ответственности: каждый компонент должен заниматься какой-то одной задачей. Если функциональность компонента увеличивается с&nbsp;течением времени, его следует разбить на&nbsp;более мелкие подкомпоненты.<br />
<br />
Многие интерфейсы работают с&nbsp;моделью данных JSON. Поэтому хорошо построенная модель, как правило, уже отражает пользовательский интерфейс (а&nbsp;значит, и&nbsp;структуру компонентов). Интерфейс и&nbsp;модели данных часто имеют похожую информационную архитектуру, так что разделить интерфейс на&nbsp;части не&nbsp;составляет труда. Разбейте его на&nbsp;компоненты, каждый из&nbsp;которых отображает часть модели данных.<br />
<br />
Диаграмма, показывающая вложенность компонентов<br />
Здесь мы&nbsp;видим, что наше приложение состоит из&nbsp;пяти различных компонентов. Курсивом выделены данные, которые эти компоненты представляют. Приведённые числа ниже соответствуют тем, что указаны на&nbsp;изображении.<br />
<br />
FilterableProductTable (оранжевый): контейнер, содержащий пример целиком<br />
SearchBar (синий): поле пользовательского ввода<br />
ProductTable (зелёный): отображает и&nbsp;фильтрует список данных, основанный на&nbsp;пользовательском вводе<br />
ProductCategoryRow (голубой): наименования категорий<br />
ProductRow (красный): отдельно взятый товар<br />
Обратите внимание, что внутри ProductTable заголовок таблицы (&laquo;Name&raquo; и&nbsp;&laquo;Price&raquo;) сам по&nbsp;себе отдельным компонентом не&nbsp;является. Отделять его или нет&nbsp;&mdash; вопрос личного предпочтения. В&nbsp;данном примере мы&nbsp;решили не&nbsp;придавать этому особого значения и&nbsp;оставить заголовок частью большего компонента ProductTable, так как он&nbsp;является всего лишь малой частью общего списка данных. Тем не&nbsp;менее, если в&nbsp;будущем заголовок пополнится новыми функциями (например, возможностью сортировать товар), имеет смысл извлечь его в&nbsp;самостоятельный компонент ProductTableHeader.<br />
<br />
Теперь, когда мы&nbsp;определили компоненты в&nbsp;нашем макете, давайте расположим их&nbsp;согласно иерархии. Компоненты, которые являются частью других компонентов, в&nbsp;иерархии отображаются как дочерние:<br />
<br />
FilterableProductTable<br />

SearchBar<br />
ProductTable<br />

ProductCategoryRow<br />
ProductRow<br />
<br />
Шаг&nbsp;2: Создадим статическое приложение в&nbsp;React<br />
<br />
Теперь, когда все компоненты расположены в&nbsp;иерархическом порядке, пришло время воплотить в&nbsp;жизнь наше приложение. Самый лёгкий способ&nbsp;&mdash; создать версию, которая использует модель данных и&nbsp;рендерит интерфейс, но&nbsp;не&nbsp;предполагает никакой интерактивности. Разделять эти процессы полезно. Написание статического приложения требует много печатания и&nbsp;совсем немного мышления. С&nbsp;другой стороны, создание интерактивного приложения подразумевает более глубокий мыслительный процесс и&nbsp;лишь долю рутинной печати. Позже мы&nbsp;разберёмся, почему так получается.<br />
<br />
Чтобы построить статическое приложение, отображающее модель данных, нам нужно создать компоненты, которые используют другие компоненты и&nbsp;передают данные через пропсы. Пропсы&nbsp;&mdash; это способ передачи данных от&nbsp;родителя к&nbsp;потомку. Если вы&nbsp;знакомы с&nbsp;понятием состояния, то&nbsp;для статического приложения это как раз&nbsp;то, чего вам использовать не&nbsp;нужно. Состояние подразумевает собой данные, которые меняются со&nbsp;временем&nbsp;&mdash; интерактивность. Так как мы&nbsp;работаем над статическим приложением, нам этого не&nbsp;нужно.<br />
<br />
Написание кода можно начать как сверху вниз (с&nbsp;большого FilterableProductTable), так и&nbsp;снизу вверх (с&nbsp;маленького ProductRow). Более простые приложения удобнее начать с&nbsp;компонентов, находящихся выше по&nbsp;иерархии. В&nbsp;более сложных приложениях удобнее в&nbsp;первую очередь создавать и&nbsp;тестировать подкомпоненты.<br />
<br />
В&nbsp;конце этого шага у&nbsp;вас на&nbsp;руках появится библиотека повторно используемых компонентов, отображающих вашу модель данных. Так как это статическое приложение, компоненты будут иметь только методы render(). Компонент выше по&nbsp;иерархии (FilterableProductTable) будет передавать модель данных через пропсы. Если вы&nbsp;внесёте изменения в&nbsp;базовую модель данных и&nbsp;снова вызовете ReactDOM.render(), то&nbsp;пользовательский интерфейс отразит эти изменения. Вы&nbsp;можете увидеть, как обновляется интерфейс и&nbsp;где следует сделать очередные изменения. Благодаря одностороннему потоку данных (или односторонней привязке), код работает быстро, но&nbsp;остаётся понятным.<br />
<br />
Если у&nbsp;вас остались вопросы по&nbsp;выполнению данного шага, обратитесь к&nbsp;документации React.<br />
<br />
Небольшое отступление: чем пропсы отличаются от&nbsp;состояния<br />
Существует два типа &laquo;модели&raquo; данных в&nbsp;React: пропсы и&nbsp;состояние. Важно, чтобы вы&nbsp;понимали разницу между ними, иначе обратитесь к&nbsp;официальной документации React. Посмотрите также раздел Какая разница между state и&nbsp;props?<br />
<br />
Шаг&nbsp;3: Определим минимальное (но&nbsp;полноценное) отображение состояния интерфейса<br />
Чтобы сделать наш&nbsp;UI интерактивным, нужно, чтобы модель данных могла меняться со&nbsp;временем. В&nbsp;React это возможно с&nbsp;помощью состояния.<br />
<br />
Чтобы правильно построить приложение, сначала нужно продумать необходимый набор данных изменяемого состояния. Главное тут следовать принципу разработки DRY: Don&rsquo;t Repeat Yourself (рус.&nbsp;не&nbsp;повторяйся). Определите минимально необходимое состояние, которое нужно вашему приложению, всё остальное вычисляйте при необходимости. Например, если вы&nbsp;создаёте список дел, держите массив пунктов списка под рукой&nbsp;&mdash; но&nbsp;не&nbsp;стоит хранить отдельное состояние для количества дел в&nbsp;списке. Если надо отобразить количество элементов&nbsp;&mdash; используйте длину существующего массива.<br />
<br />
Давайте перечислим все данные в&nbsp;нашем демо-приложении. У&nbsp;нас есть:<br />
<br />
Первоначальный список товаров.<br />
Поисковый запрос, введённый пользователем.<br />
Значение чекбокса.<br />
Отфильтрованный список товаров.<br />
Давайте рассмотрим данные по&nbsp;частям и&nbsp;определим, что должно храниться в&nbsp;состоянии. Задайте себе три вопроса:<br />
<br />
Передаются&nbsp;ли они от&nbsp;родителя через пропсы? Если так, тогда эти данные не&nbsp;должны храниться в&nbsp;состоянии компонента.<br />
Остаются&nbsp;ли они неизменными со&nbsp;временем? Если так, тогда их&nbsp;тоже не&nbsp;следует хранить в&nbsp;состоянии.<br />
Можете&nbsp;ли вы&nbsp;вычислить их&nbsp;на&nbsp;основании любых других данных в&nbsp;своём компоненте или пропсов? Если так, тогда это тоже не&nbsp;состояние.<br />
Исходный список товаров передаётся через пропсы, так что не&nbsp;нужно хранить его в&nbsp;состоянии компонента. Поисковый запрос и&nbsp;состояние чекбокса изменяются со&nbsp;временем, и&nbsp;их&nbsp;нельзя вычислить из&nbsp;других данных, так что они вполне сойдут за&nbsp;состояние. Напоследок, отфильтрованный список товаров не&nbsp;является состоянием, так как его можно вычислить из&nbsp;оригинального списка, поискового запроса и&nbsp;значения чекбокса.<br />
<br />
В&nbsp;итоге, состоянием являются:<br />
<br />
Поисковый запрос, введённый пользователем<br />
Значение чекбокса<br />
Шаг&nbsp;4: Определим, где должно находиться наше состояние<br />
<br />
Итак, мы&nbsp;определили минимальный набор состояний приложения. Далее нам нужно выяснить, какой из&nbsp;компонентов владеет состоянием или изменяет его.<br />
<br />
Помните: в&nbsp;React поток данных односторонний и&nbsp;сходит сверху вниз в&nbsp;иерархическом порядке. Сначала может быть не&nbsp;совсем ясно, какой из&nbsp;компонентов какое состояние должен хранить. На&nbsp;этом этапе новички спотыкаются чаще всего. Чтобы разобраться, следуйте этим инструкциям:<br />
<br />
Для каждой части состояния в&nbsp;приложении:<br />
<br />
Определите компоненты, которые рендерят что-то исходя из&nbsp;этого состояния.<br />
Найдите общий главенствующий компонент (компонент, расположенный над другими компонентами, которым нужно это состояние).<br />
Либо общий главенствующий компонент, либо любой компонент, стоящий выше по&nbsp;иерархии, должен содержать состояние.<br />
Если вам не&nbsp;удаётся найти подходящий компонент, то&nbsp;создайте новый исключительно для хранения состояния и&nbsp;разместите его выше в&nbsp;иерархии над общим главенствующим компонентом.<br />
Давайте применим эту стратегию на&nbsp;примере нашего приложения:<br />
<br />
Задача ProductTable&nbsp;&mdash; отфильтровать список товаров, основываясь на&nbsp;состоянии, а&nbsp;SearchBar&nbsp;&mdash; отобразить состояние для поискового запроса и&nbsp;чекбокса.<br />
Общий главенствующий компонент для обоих&nbsp;&mdash; FilterableProductTable.<br />
По&nbsp;идее, имеет смысл содержать текст фильтра и&nbsp;значение чекбокса в&nbsp;FilterableProductTable.<br />
Итак, мы&nbsp;приняли решение расположить наше состояние в&nbsp;FilterableProductTable. Первое, что нужно сделать&nbsp;&mdash; добавить свойство this.state = {filterText: &rsquo;&rsquo;, inStockOnly: false} в&nbsp;конструктор FilterableProductTable, чтобы отобразить начальное состояние нашего приложения. После этого передайте filterText и&nbsp;inStockOnly в&nbsp;ProductTable и&nbsp;SearchBar через пропсы. Напоследок, используйте пропсы для фильтрации строк в&nbsp;ProductTable и&nbsp;определения значений полей формы SearchBar.<br />
<br />
Вы&nbsp;заметите изменения в&nbsp;поведении вашего приложения: задайте значение &laquo;ball&raquo; для filterText и&nbsp;обновите страницу. Вы&nbsp;увидите соответствующие изменения в&nbsp;таблице данных.<br />
<br />
Шаг&nbsp;5: Добавим обратный поток данных<br />
Пока что наше приложение рендерится в&nbsp;зависимости от&nbsp;пропсов и&nbsp;состояния, передающихся вниз по&nbsp;иерархии. Теперь мы&nbsp;обеспечим поток данных в&nbsp;обратную сторону: наша задача сделать так, чтобы компоненты формы в&nbsp;самом низу иерархии обновляли состояние в&nbsp;FilterableProductTable.<br />
<br />
Поток данных в&nbsp;React&nbsp;&mdash; однонаправленный. Это помогает понять, как работает приложение, но&nbsp;нам потребуется немного больше кода, чем с&nbsp;традиционной двусторонней привязкой данных.<br />
<br />
Если вы&nbsp;попытаетесь ввести текст в&nbsp;поле поиска или установить флажок в&nbsp;чекбоксе данного примера, то&nbsp;увидите, что React игнорирует любой ввод. Это закономерно, так как ранее мы&nbsp;приравняли значение пропа value в&nbsp;input к&nbsp;state в&nbsp;FilterableProductTable.<br />
<br />
Давайте подумаем, как мы&nbsp;хотим изменить поведение. Нам нужно, чтобы при изменениях поисковой формы менялось состояние ввода. Так как компоненты должны обновлять только относящееся к&nbsp;ним состояние, FilterableProductTable передаст колбэк в&nbsp;SearchBar. В&nbsp;свою очередь, SearchBar будет вызывать этот колбэк каждый раз, когда надо обновить состояние. Чтобы получать уведомления об&nbsp;изменениях элементов формы, мы&nbsp;можем использовать событие onChange. Колбэки, переданные из&nbsp;компонента FilterableProductTable, вызовут setState(), и&nbsp;приложение обновится.<br />
<br />
Вот и&nbsp;всё<br />
Надеемся, что этот пример поможет вам получить представление о&nbsp;том, как подойти к&nbsp;созданию компонентов и&nbsp;приложений в&nbsp;React. Хотя этот процесс и&nbsp;использует немного больше кода, помните, что код читают чаще, чем пишут. А&nbsp;модульный и&nbsp;прямолинейный код читается значительно легче. Когда вы&nbsp;начнёте создавать большие библиотеки компонентов, вы&nbsp;сможете по-настоящему оценить прямолинейность и&nbsp;связанность React, а&nbsp;повторно используемые компоненты сделают ваш код намного меньше.
            </article>
        </section>
    </main>
    <footer>
        <h1 style="color: white;">React Blog</h1>
        <img class="header-img" style="width: 100px; height: 100px;" src="1.png" alt="">
        <div>
            <img style="padding: 10px;" src="facebook.png" alt="">
            <img style="padding: 10px;" src="twitter.png" alt="">
            <img style="padding: 10px;" src="G+.png" alt="">
            <img style="padding: 10px;" src="p.png" alt="">
        </div>
    </footer>
</body>
</html>
